# 由HAN LIN TUN进行完成编写
# 完整的函数并已经进行模块化

import os
import json
import difflib
import hashlib
import bridge

report = {}
report["判定结果"] = []

# 从文件中加载JSON数据
def load_json(filename):
    try:
        with open(filename, 'r') as file:
            return json.load(file)
    except FileNotFoundError:
        report["判定结果"].append(f"文件 {filename} 未找到。")
        print(f"文件 {filename} 未找到。")
        return None
    except json.JSONDecodeError:
        report["判定结果"].append(f"文件 {filename} 不是合法的JSON文件。")
        print(f"文件 {filename} 不是合法的JSON文件。")
        return None
    except Exception as e:
        report["判定结果"].append(f"读取文件 {filename} 出错：{e}")
        print(f"读取文件 {filename} 出错：{e}")
        return None

# 读取文件
def read_file(file_path):
    try:
        if "tensorflow" in file_path:
            file_path = "./source/" + file_path
        with open(file_path, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        report["判定结果"].append(f"错误：找不到文件 {file_path}")
        print(f"错误：找不到文件 {file_path}")
        return None
    except Exception as e:
        report["判定结果"].append(f"读取文件 {file_path} 时出错：{e}")
        print(f"读取文件 {file_path} 时出错：{e}")
        return None

# 获取哈希值
def hash_lines(lines):
    return hashlib.md5("".join(lines).encode()).hexdigest()

# 第一步，根据版本号查找CVE IDs
def find_cve_ids_by_version(version, merged_file='./dataset/json/merged_final.json', num_cve_file='./dataset/json/template_for_VUL.json'):
    data_merged = load_json(merged_file)
    data_num_cve = load_json(num_cve_file)

    if data_merged is None or data_num_cve is None:
        return []
    no_to_cve = {entry['No.']: entry['CVE ID'] for entry in data_num_cve}
    content = data_merged.get(version, [])
    found_cve_ids = []

    for target_no in content:
        target_cve_id = no_to_cve.get(target_no)
        if target_cve_id:
            found_cve_ids.append(target_cve_id)
        else:
            report["判定结果"].append(f"No entry found for No {target_no}")
            print(f"No entry found for No {target_no}")
    return found_cve_ids

# 第二步，将客户提供的文件根据名称(路径)在本地CWE漏洞文件中查找相同名称的文件并记录它的CVE IDs（客户会有很多个文件，在这里要进行循环）
def find_target_file_in_cve(cwe_folder_path, target_file):
    found_cve_folders_local = set()

    if not os.path.exists(cwe_folder_path):
        report["判定结果"].append(f"指定的CWE文件夹路径 {cwe_folder_path} 不存在。")
        print(f"指定的CWE文件夹路径 {cwe_folder_path} 不存在。")
        return found_cve_folders_local

    for cwe in os.listdir(cwe_folder_path):
        cwe_path = os.path.join(cwe_folder_path, cwe)
        if os.path.isdir(cwe_path):
            for cve in os.listdir(cwe_path):
                cve_path = os.path.join(cwe_path, cve)
                if os.path.isdir(cve_path):
                    for status_folder in ["PATCHED", "VULN"]:
                        status_folder_path = os.path.join(cve_path, status_folder)
                        if os.path.exists(status_folder_path):
                            if target_file in os.listdir(status_folder_path):
                                report["判定结果"].append(f"文件 {target_file} 在 {cve_path}/{status_folder} 中找到。")
                                print(f"文件 {target_file} 在 {cve_path}/{status_folder} 中找到。")
                                found_cve_folders_local.add(cve)
                        else:
                            report["判定结果"].append(f"预期的 {status_folder} 文件夹不存在：{status_folder_path}")
                            print(f"预期的 {status_folder} 文件夹不存在：{status_folder_path}")

    return found_cve_folders_local

# 第三步，将得到的CVE IDs去和第一步里面的CVE IDs做对比，筛选出真正存在于该版本的漏洞（做交集）
# def check_vulnerable_cve(found_cve_folders, found_cve_ids):
#     intersection = found_cve_folders.intersection(set(found_cve_ids))
#     if not intersection:
#         print("不属于漏洞文件")
#     else:
#         print(f"该文件存在于以下漏洞CVE中：{', '.join(intersection)}")
#
#     return intersection  # 返回交集，以供其他函数使用

def check_vulnerable_cve(found_cve_folders, found_cve_ids, checked_cve_ids):
    intersection = set(found_cve_folders).intersection(set(found_cve_ids))
    if not intersection:
        #report["判定结果"].append(f"不属于漏洞文件\n")
        print("不属于漏洞文件")
    else:
        #report["判定结果"].append(f"该文件存在于以下漏洞CVE中：{', '.join(intersection)}")
        print(f"该文件存在于以下漏洞CVE中：{', '.join(intersection)}")
        checked_cve_ids.update(intersection)  # 更新已检查的CVE IDs

    return intersection  # 返回交集，以供其他函数使用

# 对比两个文件并提取差异内容的行号，差异内容只提取位于file1中内容
def compare_files(file1_lines, file2_lines, line_tolerance=0):
    d = difflib.Differ()
    diff = list(d.compare(file1_lines, file2_lines))

    line_numbers = []
    diff_content = []
    count1 = 1

    for line in diff:
        if line.startswith('  '):
            count1 += 1
        elif line.startswith('- '):
            line_numbers.append(count1)
            diff_content.append(line[2:].strip())
            count1 += 1

    return diff_content, line_numbers

# CVE ID和CWE ID的映射
def create_cwe_to_cve_mapping(json_file):
    data = load_json(json_file)
    mapping = {}
    for entry in data:
        cwe_id = entry.get('CWE ID')
        cve_id = entry.get('CVE ID')
        if cwe_id is not None and cve_id is not None:
            mapping[cve_id] = cwe_id
    return mapping

# 差异内容是否在另一个文件中
def is_subset_with_tolerance(diff_lines, target_lines, line_numbers, tolerance):
    for diff, line_num in zip(diff_lines, line_numbers):
        found = False
        for i in range(line_num - tolerance, line_num + tolerance + 1):
            if i <= 0 or i > len(target_lines):
                continue
            if diff == target_lines[i - 1].strip():
                found = True
                break
        if not found:
            return False
    return True

# 用来分析客户文件，官方漏洞文件和官方补丁文件函数并生成修补状态评估
def analyze_files(patched_file_path, vuln_file_path, target_file_path, line_tolerance=5):
    patched_lines = read_file(patched_file_path)
    vuln_lines = read_file(vuln_file_path)
    target_lines = read_file(target_file_path)

    if any(line is None for line in [patched_lines, vuln_lines, target_lines]):
        report["判定结果"].append("由于至少一个文件未能成功读取，因此无法继续执行。")
        print("由于至少一个文件未能成功读取，因此无法继续执行。")
        print("")
        return

    # 文件哈希比较，检查是否完全相同
    if hash_lines(patched_lines) == hash_lines(target_lines):
        report["判定结果"].append("客户文件是使用官方修补过的文件，安全。")
        report["判定结果"].append("")
        print("客户文件是使用官方修补过的文件，安全。")
        print("")
        return
    elif hash_lines(vuln_lines) == hash_lines(target_lines):
        report["判定结果"].append("客户文件是使用官方原有的漏洞文件，不安全。")
        print("客户文件是使用官方原有的漏洞文件，不安全。")
        print("")
        return

    patched_diff, patched_line_numbers = compare_files(patched_lines, vuln_lines)
    target_diff, target_line_numbers = compare_files(target_lines, vuln_lines)

    report["判定结果"].append(f"官方修补文件与漏洞文件的差异行号：{patched_line_numbers}")
    report["判定结果"].append(f"客户文件与漏洞文件的差异行号：{target_line_numbers}")
    print(f"官方修补文件与漏洞文件的差异行号：{patched_line_numbers}")
    print(f"客户文件与漏洞文件的差异行号：{target_line_numbers}")

    if is_subset_with_tolerance(patched_diff, target_lines, patched_line_numbers, line_tolerance):
        report["判定结果"].append("客户文件似乎使用了官方的修补方案，安全。")
        report["判定结果"].append(f"")
        print("客户文件似乎使用了官方的修补方案，安全。")
        print("")
    else:
        common_line_numbers = set(patched_line_numbers).intersection(set(target_line_numbers))
        unique_to_patched = set(patched_line_numbers) - common_line_numbers
        unique_to_target = set(target_line_numbers) - common_line_numbers

        report["判定结果"].append(f"客户文件和官方修补文件共同的修补行号：{sorted(common_line_numbers)}")
        report["判定结果"].append(f"只在官方修补文件中出现的修补行号：{sorted(unique_to_patched)}")
        report["判定结果"].append(f"只在客户文件中出现的修补行号：{sorted(unique_to_target)}")
        print(f"客户文件和官方修补文件共同的修补行号：{sorted(common_line_numbers)}")
        print(f"只在官方修补文件中出现的修补行号：{sorted(unique_to_patched)}")
        print(f"只在客户文件中出现的修补行号：{sorted(unique_to_target)}")

        if len(unique_to_target) > len(unique_to_patched):
            report["判定结果"].append(f"客户文件自行修改了文件，但没有完全采用官方的修补方案，不安全。")
            report["判定结果"].append(f"")
            print("客户文件自行修改了文件，但没有完全采用官方的修补方案，不安全。")
            print("")
        else:
            report["判定结果"].append(f"客户文件自行修补了漏洞，位置与官方修补文件相似，安全性未知。")
            report["判定结果"].append(f"")
            print("客户文件自行修补了漏洞，位置与官方修补文件相似，安全性未知。")
            print("")

# 主函数
def main(version, customer_files):
    print("")
    print("##############################################################################################################################################################")
    print("COMMENCING CVE CHECK")
    print("##############################################################################################################################################################")
    try:
        # 现根据版本号得到CVE ID
        found_cve_ids = find_cve_ids_by_version(version)
        #print(found_cve_ids)

        checked_cve_ids = set()
        if not found_cve_ids:
            report["判定结果"].append("未找到与指定版本相关的CVE IDs。")
            print("未找到与指定版本相关的CVE IDs。")
            return

        # 映射CWE ID和CVE ID之间的关系
        cwe_to_cve_mapping = create_cwe_to_cve_mapping("./dataset/json/template_for_VUL.json")
        if cwe_to_cve_mapping is None:
            report["判定结果"].append("未能创建CWE到CVE的映射。")
            print("未能创建CWE到CVE的映射。")
            return

        # 对每个客户文件进行循环
        for target_file in customer_files:
            # 第一步，根据客户文件去json文件中查看该路径对应的CVE ID，如果没有则下一个，如果有则记录该ID
            data_path = load_json("./dataset/json/template_for_VUL.json")

            # 初始化一个空列表来保存所有匹配的 CVE ID
            matching_cve_ids = []

            # 遍历 JSON 数据
            for entry in data_path:
                # 检查 "Path" 键是否存在，并且是否包含给定的路径
                if "Path" in entry and target_file in entry["Path"].split(';'):
                    # 如果找到匹配，将 "CVE ID" 添加到列表中
                    matching_cve_ids.append(entry["CVE ID"])
            # 检查是否找到匹配的 CVE ID
            if len(matching_cve_ids) == 0:
                report["判定结果"].append(f"没有找到与 {target_file} 匹配的CVE ID，继续下一个客户文件。")
                report["判定结果"].append("")
                print("")
                print(f"没有找到与 {target_file} 匹配的CVE ID，继续下一个客户文件。")
                print("")
                continue  # 继续下一个客户文件
            #report["判定结果"].append(f"找到与 {target_file} 匹配的CVE ID：{matching_cve_ids}")
            print(f"找到与 {target_file} 匹配的CVE ID：{matching_cve_ids}")

            # 打印所有匹配的 CVE ID
            if matching_cve_ids:
                #report["判定结果"].append(f"匹配的 CVE ID:{matching_cve_ids}")
                print("匹配的 CVE ID: ", matching_cve_ids)
            else:
                report["判定结果"].append("没有找到匹配的 CVE ID。")
                print("没有找到匹配的 CVE ID。")

            # 如果找到匹配的 CVE ID，将该ID和版本中存在的ID进行交集，如果没有存在交集则代表该漏洞没有在提供的版本里，如果有交集，记录下CVE ID
            matchig_cves = check_vulnerable_cve(set(matching_cve_ids), found_cve_ids, checked_cve_ids)
            if not matchig_cves:
                continue

            # 找到匹配的CVE ID，储存在matching_cves里面
            # 假设一个路径对应一个CVE ID，并且该CVE ID还在版本CVE ID里面，代表该文件有漏洞，那么下面要进行文件匹配了
            # 问题是怎么得到该路径对应的官方有/无漏洞文件

            # 假设会有很多个CVE ID
            for cve in matchig_cves:
                if cve not in bridge.report_dict["CVE"]:
                    bridge.report_dict["CVE"].append(cve)
                # 先拿到对应CVE的CWE
                cwe_id = cwe_to_cve_mapping.get(cve)
                report["判定结果"].append(cve)
                #report["判定结果"].append(f"漏洞存在CWE类型为CWE{cwe_id}")
                print("该漏洞存在的CWE类型为", cwe_id)
                if cwe_id is None:
                    report["判定结果"].append(f"找不到CWE ID与CVE {cve} 相对应。跳过...")
                    print(f"找不到CWE ID与CVE {cve} 相对应。跳过...")
                    continue

                # 提取客户文件路径里的文件名，方便在CWE文件里面查找
                target_file_base = os.path.basename("./source/" + target_file)  # 提取文件名
                #report["判定结果"].append(f"客户文件的文件名{target_file_base}")
                print("客户文件的文件名", target_file_base)

                # 去CWE文件找到具体有漏洞和补丁文件
                # 使用CWE ID构建文件路径
                cwe_folder = f"CWE{cwe_id}"

                 # 官方补丁文件路径，在PATCHED下
                patched_file_path = os.path.join("./dataset/CWE", cwe_folder, cve, "PATCHED", target_file_base)
                report["判定结果"].append(f"修补文件的路径为{patched_file_path}")
                print("修补文件的路径为", patched_file_path)
                # 官方漏洞文件路径，在VULN下
                vuln_file_path = os.path.join("./dataset/CWE", cwe_folder, cve, "VULN", target_file_base)
                report["判定结果"].append(f"漏洞文件的路径为{vuln_file_path}")
                print("漏洞文件的路径为", vuln_file_path)

                # 客户文件是target_file
                report["判定结果"].append(f"开始分析文件 {target_file} 的CVE：{cve}")
                print(f"开始分析文件 {target_file} 的CVE：{cve}")
                analyze_files(patched_file_path, vuln_file_path, target_file)

        # 找出没有做过交集的CVE IDs
        unchecked_cve_ids = set(found_cve_ids).difference(checked_cve_ids)
        if unchecked_cve_ids:
            # print(f"以下CVE IDs没有做过交集：{', '.join(unchecked_cve_ids)}")
            report["判定结果"].append(f"该版本中还存在的漏洞为：{', '.join(unchecked_cve_ids)}")
            print(f"该版本中还存在的漏洞为：{', '.join(unchecked_cve_ids)}")
        else:
            report["判定结果"].append(f"以成功检查该版本中所有存在的漏洞")
            print("以成功检查该版本中所有存在的漏洞")

            # if found_cve_folders:
            #     # 记录同名文件的上一级目录，也就是CVE ID，并将改ID和从版本中提取出来的CVE ID做交集，来判断该文件的CVE是否真的存在于该版本中的CVE
            #     vulnerable_cves = check_vulnerable_cve(found_cve_folders, found_cve_ids)
            #
            #     # 对每个找到的CVE ID进行循环
            #     for cve in vulnerable_cves:
            #         cwe_id = cwe_to_cve_mapping.get(cve)
            #         if cwe_id is None:
            #             print(f"找不到CWE ID与CVE {cve} 相对应。跳过...")
            #             continue
            #
            #         # 使用CWE ID构建文件路径
            #         cwe_folder = f"CWE{cwe_id}"
            #
            #         # 官方补丁文件路径，在PATCHED下
            #         patched_file_path = os.path.join("CWE", cwe_folder, cve, "PATCHED", target_file)
            #
            #         # 官方漏洞文件路径，在VULN下
            #         vuln_file_path = os.path.join("CWE", cwe_folder, cve, "VULN", target_file)
            #
            #         # target_file_path = os.path.join("客户文件夹的路径", target_file)  # 这里设置客户文件夹的路径
            #         target_file_path = os.path.join("test", target_file)
            #         print(f"开始分析文件 {target_file} 的CVE：{cve}")
            #         analyze_files(patched_file_path, vuln_file_path, target_file_path)
            # else:
            #     print(f"文件 {target_file} 没有找到匹配的CVE文件夹。")

    except Exception as e:
        report["判定结果"].append(f"主函数执行过程中发生错误：{e}")
        print(f"主函数执行过程中发生错误：{e}")

    print("")
    print("CHECK DONE!")

def return_dict():
    return report

# version和customer_files接收输入
