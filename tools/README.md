<!--
 * @Author: Suez_kip 287140262@qq.com
 * @Date: 2023-09-20 20:58:43
 * @LastEditTime: 2023-11-19 11:59:35
 * @LastEditors: Suez_kip
 * @Description: 
-->
# 补丁判别技术路线

## 相关源

下文中包含的Content有：待测文件、CVE补丁前片段、CVE补丁后片段、Fixing Commit前版本源码（版本源码）、Fixing Commit后版本源码；

## 具体路线

1. 提取官方补丁 $P_o$ （Official Patch），从Commit Slice的Fixing前后进行提取，分别获取 $P_o$ 中的**补丁前文件（删改）**，**补丁后文件（增改）**单独包含的代码行；
2. 查看待修补片段完整性（在放弃无语义差异情况下，看Fixing Commit Slice修补前（下简称CSBF Commit Slice Before Fixing）是否在待测源码里完整且连续地匹配存在）：
   1. 若完整，说明待测源码未修改 $P_o$ 修改位置FCS的代码；
   2. 若不完整，说明待测源码直接修改在 $P_o$ 修改位置FCS的代码；
3. 若不完整，则有以下两种方案：
   1. 直接将之判定为对漏洞进行了修补；
   2. 通过FCS定位到函数，针对该函数，通过AST的差异性分析评分（分别分析从Fixing Commit前版本源码到Fixing Commit后版本源码和待测文件的Diff，然后比较这两者的相似性）；
4. 若完整，考虑补丁 $P_p$ 是否对待测代码中官方补丁修改内容(抽象至参数级别)涉及的控制流进行了影响：
   1. 由于待测补丁的修补分为了增改（仅仅出现在了待测文件源码中）和删改（仅仅出现在了包含漏洞的源码中），因此分析需要的是同时分析待测源码，使用工具提取待测源码文件（包含 $P_p$ 的增改内容）、版本源码（包含 $P_p$ 的删改内容）完整控制流；
   2. 用工具提取版本源码文件内参数，观察哪些参数存在于 $P_o$ 补丁前（删改）， $P_o$ 补丁后（增改）的单独包含代码片段内，如果出现在其中，则说明该参数疑似为漏洞相关修复参数 $Param$ ；
   3. 通过版本源码找到 $Param$ 所在的代码行，并进一步确定改代码行对应的CFG中节点 $N_{param}$ ；
   4. 基于漏洞相关修复参数 $Param$ 和文件完整控制流进行广度遍历，进一步提取出完整漏洞相关修复参数片段控制流子图 $G$ ；
5. 针对任意 $G$ ，我们观察 $N_{param}\cap G$ 是否为空集：
    1. 如果 $N_{param}\cap G=\emptyset$ ，则说明补丁P于基准补丁完全无关，即P是无关补丁；
    2. 如果 $N_{param}\cap G\not ={\emptyset}$ ，则说明这段交集就是与漏洞相关修复参数片段相关；
